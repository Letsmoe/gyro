import {COLORS, color} from "./color.js";
import {generateHelp} from "./help.js";
import {Option, Type} from "./types"

function colarg(argv : string[]) {
	function parseArguments(argv : string[], optionList: {[key: string]: Option}) : {[key: string]: any} {
		const executeFunctions = [];

		let foundArguments = {_default: []};
		// Loop through given options to pre-assign default values.
		for (const opt in optionList) {
			let optVal = optionList[opt];
			if (optVal.callback) {
				// It is a command, don't add it to the list of arguments
				continue
			}
			foundArguments[optVal.alias] = optVal.default;
			foundArguments[opt] = optVal.default;
		}
		let args = {
			index: 0,
			next: function() {
				let value = argv[this.index]
				this.index++
				return value;
			},
			peek: function() {
				if (this.index === argv.length) {
					return null
				}
				return argv[this.index]
			}
		}

		const setOption = (name: string, opt: Option, value : string) => {
			let type = opt.type, newValue: string | boolean | number = value;
			if (type === "boolean") {
				newValue = value === "true" ? true : false;
			} else if (type === "number") {
				newValue = parseInt(value);
			} else if (type === "string") {
				newValue = value.toString();
			}
			
			foundArguments[opt.alias] = newValue;
			foundArguments[name] = newValue;
		};

		const captureCommand = (opt: Option) => {
			let argArray : string[] = []
			let value: string;
			while ((value = args.peek())) {
				if (value.startsWith("-")) {
					break;
				}
				argArray.push(args.next());
			}

			if (opt.callback) {
				executeFunctions.push(() => opt.callback(foundArguments, ...argArray));
			}
		}

		while(args.peek()) {
			let arg = args.next()
			let value: string | boolean | number, option : Option, argName: string;
			// Assume the first argument to be a name.
			if (arg.startsWith("--")) {
				// Named argument, lookup the mains
				argName = arg.substring(2);
				if (optionList.hasOwnProperty(argName)) {
					option = optionList[argName];
					value = args.next()
					setOption(argName, option, value);
				} else {
					process.stdout.write("Invalid property passed: " + argName);
				}
			} else if (arg.startsWith("-")) {
				// Aliased argument
				argName = arg.substring(1);
				for (const key in optionList) {
					if (optionList[key].alias === argName) {
						option = optionList[key];
						value = args.next()
						setOption(key, option, value);
						break;
					}
				}
			} else {
				// Check if it is a command
				if (optionList.hasOwnProperty(arg)) {
					option = optionList[arg];
					captureCommand(option);
					continue
				}
				// Assume argument to be a value.
				value = arg
			}

			if (!argName) {
				// Add it to the list of default arguments.
				if (parserOptions.CAPTURE_DEFAULTS) {
					foundArguments._default.push(value);
				} else {
					console.log("We're not taking someone onboard who doesn't even know their name! Go away!")
					process.exit(0)
				}
			}
		}

		// Iterate over the arguments once to check if every required option is fulfilled.
		for (const key in optionList) {
			let option = optionList[key];
			if (option.required && !foundArguments[key]) {
				console.log(`Missing required argument: --${key} | -${option.alias}`);
				process.exit(0);
			}
		}

		executeFunctions.forEach(fn => fn());
		return foundArguments;
	}

	const optionList : {[key: string]: Option} = {};
	const parserOptions = {
		CAPTURE_DEFAULTS: true,
	}
	var usageString : string;

	const obj = {
		options: (opts : {[key: string]: Option}) => {
			for (let key in opts) {
				optionList[key] = opts[key]
			}
			return obj
		},
		get args() {
			return parseArguments(argv, optionList);
		},
		option: (name: string, alias: string, def: any, desc: string, required: boolean = false, type: Type = "string") => {
			optionList[name] = {
				alias: alias,
				desc: desc,
				type: type,
				default: def,
				required: required
			}
			return obj
		},
		command: (name: string, desc: string, callback: Function) => {
			optionList[name] = ({desc: desc, callback: callback} as Option);
			optionList[name].callback = callback

			return obj
		},
		usage: (usage: string) => {
			usageString = usage;
			return obj
		},
		set: (optionName: string, value: boolean | string | number) => {
			parserOptions[optionName] = value;
			return obj
		},
		help: function() {
			this.command("help", "Displays this message and exits.", () => {
				generateHelp(optionList, usageString);
			})
			return obj;
		}
	}

	return Object.freeze(obj);
}

export {colarg, COLORS, color}